from pathlib import Path
from multiprocessing import Pool
import os
import subprocess
import pandas as pd

configfile: "config.yaml"

SOFTWAREPATH = "/hps/software/users/iqbal/daria"
GENOMESPATH = config["genomes_list"]
FASTAPATH = config["fastas"]
OUTPUTPATH = config["output_dir"]
PREFIX = config["prefix"]
GENOMES = pd.read_csv(GENOMESPATH, sep='\t', index_col=None, header=None).iloc[:,0].values.tolist()

def get_dist_files():
    genome_pairs=[]
    n = len(GENOMES)
    for i in range(n):
        j=0
        while j<i:
            genome_pairs.append([GENOMES[i], GENOMES[j]])
            j=j+1
    files = []
    for el in genome_pairs:
        if len(el)>1:
            files.append(OUTPUTPATH+"/"+PREFIX+"/dists/"+el[0]+"~"+el[1]+".dist")
    return files

#localrules: all, unimog_to_ilp, dcj_dist, dcj_matrix

rule all:
    input:
        trees = OUTPUTPATH+"/"+PREFIX+"/trees/"+PREFIX+".tree"

rule make_unimogs:
    input:
        genome_1_fasta=FASTAPATH+"/{genome1}.fasta",
        genome_2_fasta=FASTAPATH+"/{genome2}.fasta"
    output:
        unimogs=OUTPUTPATH+"/"+PREFIX+"/unimogs/{genome1}~{genome2}_unimog.txt"
    params:
        genome1 = lambda wildcards: wildcards.genome1,
        genome2 = lambda wildcards: wildcards.genome2
    conda:
    	"envs/integerise.yaml"
    script:
        "unimog.py"

rule unimog_to_ilp:
    input:
        unimogs=OUTPUTPATH+"/"+PREFIX+"/unimogs/{genome1}~{genome2}_unimog.txt"
    output:
        out_id_file=OUTPUTPATH+"/"+PREFIX+"/ilp/{genome1}~{genome2}_id.txt",
        out_cplex_lp=OUTPUTPATH+"/"+PREFIX+"/ilp/{genome1}~{genome2}_cplex.cpo"
    conda:
        "envs/ding.yaml"
    resources:
        mem_mb = lambda wildcards, attempt: attempt * 1000
    shell:
        SOFTWAREPATH+"/ding/unimog_to_ilp.py -i {input.unimogs} -u {output.out_id_file} -o {output.out_cplex_lp}"

rule ilp:
    input:
        cplex_lp = OUTPUTPATH+"/"+PREFIX+"/ilp/{genome1}~{genome2}_cplex.cpo"
    output:
        solution = OUTPUTPATH+"/"+PREFIX+"/ilp/{genome1}~{genome2}.sol"
    resources:
        mem_mb = lambda wildcards, attempt: {1: 50000, 2: 100000, 3: 200000}[attempt]
    threads: 1
    shell:
        #ilp solver
        SOFTWAREPATH+"/CPLEX_Studio129/cplex/bin/x86-64_linux/cplex -c \"set threads {threads}\" \"read {input.cplex_lp} lp\" \"mipopt\" \"write {output.solution}\""

rule dcj_dist:
    input:
        solution = OUTPUTPATH+"/"+PREFIX+"/ilp/{genome1}~{genome2}.sol",
        out_id_file = OUTPUTPATH+"/"+PREFIX+"/ilp/{genome1}~{genome2}_id.txt"
    output:
        dist_file = OUTPUTPATH+"/"+PREFIX+"/dists/{genome1}~{genome2}.dist",
        out_unimog_relabeled = OUTPUTPATH+"/"+PREFIX+"/unimogs/relabelled/{genome1}~{genome2}_relabelled.txt"
    conda:
        "envs/ding.yaml"
    resources:
        mem_mb = lambda wildcards, attempt: attempt * 1000
    shell:
        SOFTWAREPATH+"/ding/parse_cplex_sol.py -i {input.solution} -u {input.out_id_file} -o {output.out_unimog_relabeled} -d {output.dist_file} --noheader"

rule dcj_matrix:
    input:
        dist_files = lambda wildcards: get_dist_files()
    output:
        matrix=OUTPUTPATH+"/"+PREFIX+"/dists/"+PREFIX+".dist"
    params:
        genomes= GENOMES
    run:
        dist=0
        distances = pd.DataFrame(index = [len(params.genomes)] + params.genomes, columns = params.genomes)
        for genome1 in params.genomes:
            i=0
            for genome2 in params.genomes:
                if genome1 == genome2:
                    dist = 0
                else:
                    file = OUTPUTPATH+"/"+PREFIX+"/dists/"+genome1+"~"+genome2+".dist"
                    if os.path.exists(file)==False:
                        file = OUTPUTPATH+"/"+PREFIX+"/dists/"+genome2+"~"+genome1+".dist"
                    dist = pd.read_csv(file, header=None, index_col=None, sep="\t").iloc[0,2]
                distances.loc[genome1, genome2]=dist
                i=i+1
        distances.to_csv(output.matrix, sep="\t", header=False)

rule trees:
    input:
        OUTPUTPATH+"/"+PREFIX+"/dists/"+PREFIX+".dist"
    output:
        OUTPUTPATH+"/"+PREFIX+"/trees/"+PREFIX+".tree"
    resources:
        mem_mb = lambda wildcards, attempt: attempt * 1000
    shell:
        SOFTWAREPATH+"/rapidNJ/bin/rapidnj {input} -i pd -x {output}"
